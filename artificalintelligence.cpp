#include <iostream>
#include <iomanip>
#include "artificalintelligence.h"



artificalintelligence::artificalintelligence()
{

   /* boardAI = new int * [SZ];
     for (int i = 0; i < SZ; i++)
         boardAI[i] = new int[SZ];

     for (int i = 0; i < SZ; i++)
         for (int j = 0; j < SZ; j++)
             boardAI[i][j] = 0;*/

}

////////////////////////////////////////////////////
///////////////////////////////////////////////////
//////////////////////////////////////////////////


int mas[16] = { 1, 5, 4, 7, 3, 8, 6, 2, 10, 13, 11, 14, 12, 9, 15, 0};


/*void artificalintelligence::BoardToMass(int** board)
{
    int k = 0;
    for (int i = 0; i < SZ - 1; i++)
        for (int j = 0; j < SZ - 1; j++)
            board[i][j] = mas[k];
            k++;
}*/

struct Cell//для трассера
{
    int F, G, H, Direct, Poz;
};

int n_block[16];//массив блокированных элементов
int map_15[16] = { -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };//массив собранных и блокированных элементов
int close_list[16];//массив закрытых при трассировке элементов
int mass_a[4];//массив окружения элемента [0]=слева,[1]=справа,[2]=сверху,[3]=снизу (если рядом нет ячеек или блокированы, то содержит -1, если есть то номер ячейки)
int Min_F = 100;


int trassa[16];//массив точек маршрута
Cell open_list[16];//массив открытых при трассировке элементов






void artificalintelligence::autoAssembly()
{
    int n = 0;

    std::cout << "Если хотите запустить ИИ нажмите 1:" << std::endl;
    std::cin >> n;
   if (n == 1)
   {Trasser_Init();
       if (MakeOneLine())// Собрать 1-й ряд
        {
           Trasser_Init();

            if (MakeTwoLine())// Собрать 2-й ряд
            {
                Trasser_Init();

                if (MakeEndLine())//остальные 2 ряда
                {

                    showBoardAI();

                    std::cout << "Всё собрано" << std::endl;
                }
                else //остальные 2 ряда
                {
                    std::cout << "Несобираемая комбинация" << std::endl;
                }
            }
            else // Собрать 2-й ряд
            {
                std::cout << "Ошибка во 2-ом ряду!" << std::endl;
            }
        }
        else // Собрать 1-й ряд
        {
            std::cout << "Ошибка во 1-ом ряду!" << std::endl;
        }
     }
}

///////////////////////////////////////////////////////

void artificalintelligence::Trasser_Init(void) //инициализация массивов для трассера
{
     for(int i = 0;i < 16; i++)//инициализация массивов (-1)
        {
        close_list[i] = -1;
        if(map_15[i] == i)//если в массиве собр элементов уже есть элемент то переносим его в в закрытый лист
            close_list[i] = i;//переносим элемент из массива сборки в массив закрытых при трассировке элементов

        if(n_block[i] == i)//если в массиве блокировок уже есть элемент то переносим его в закрытый лист
            close_list[i] = i;//переносим элемент из массива блокировки в массив закрытых при трассировке элементов

        trassa[i] = -1;//массив точек маршрута
                    //обнуляем массив открытый список точек
        open_list[i].F =0;
        open_list[i].G =0;
        open_list[i].H =0;
        open_list[i].Poz =0;
        }
        Min_F =100;

}

////////////////////////////////////////////////////

bool artificalintelligence::MakeOneLine(void)
{
    //static int coun_er=0;
    static bool result = false;
    Trasser_Init();//инициализация массивов
    if(mas[0]==1 && mas[1]==2 && mas[2]==3 && mas[3]==4)//если 1,2,3,4  на свойх местах то нам повезло
    {
        map_15[0]=0;map_15[1]=1;map_15[2]=2;map_15[3]=3;//блокируем весь ряд он сложен
        return true; //возвращаемся нам повезло!!!!
    }
            //сборка 1-го ряда **************************************************************************************

                Set_ElementPosition(1,0);
                if(mas[0]==1)
                    map_15[0]=0; //блокируем ячейку 0 (с цифрой 1)
                Trasser_Init();
                Set_ElementPosition(2,1);
                if(mas[1]==2)
                    map_15[1]=1; //блокируем ячейку 1 (с цифрой 2)
                Trasser_Init();
                if(mas[0]==1&&mas[1]==2)//Если первая и вторя ячейка на месте
                {

L1:					if(mas[2]==4)//Если цифра 4 случайно была установлена на позицию 2 тогда сдвигаем ее в поз 11, если этого не сделать, то она заблокируется в ряду и ее невозможно будет вынуть
                    Trasser_Init();
                    Set_ElementPosition(4,11);

                    Set_ElementPosition(3,3);
                    if(mas[3]==3)//Если ячейка 3 на месте
                        map_15[3]=3; //блокируем ячейку 3 (с цифрой 3)
                    Trasser_Init();

                    Set_ElementPosition(4,7);//ставим 4 в ячейку 7
                    if(mas[7]==4)
                        map_15[7]=7; //блокируем ячейку 7 (с цифрой 4)
                    Trasser_Init();

                    if((mas[3]==3)&&(mas[7]==4))
                    {
                        ZeroPositions(2);//ставим пустую ячейку на ячейку 2
                        map_15[3]=-1; //снимаем блокировку с ячейки 3 (с цифрой 3)
                        map_15[7]=-1; //снимаем блокировку с ячейки 7 (с цифрой 4)
                        Trasser_Init();
                        SwapElements(3);//ставим  3 в ячейку 2
                        SwapElements(7);//ставим  4 в ячейку 3
                        if((mas[2]==3)&&(mas[3]==4))//если 3 и 4 в своих ячейках
                            {
                            map_15[2]=2; //блокируем ячейку 2 (с цифрой 3)
                            map_15[3]=3; //блокируем ячейку 3 (с цифрой 4)
                            Trasser_Init();
                            }
                        else
                            {
                            map_15[2]=-1; //разблокируем ячейку 2 (с цифрой 3)
                            map_15[3]=-1; //разблокируем ячейку 3 (с цифрой 4)
                            Trasser_Init();
                            goto L1;
                            }

                    }
                }
                Trasser_Init();
                result=true;


return result;
}

//////////////////////////////////////////////////////////////

bool artificalintelligence::MakeTwoLine(void)
{
    int coun_er=0;//счетчик зацикливания
    bool result=false;
    L0:	if(mas[4]==5 && mas[5]==6 && mas[6]==7 && mas[7]==8)//если элементы 5,6,7,8 на свойх местах
        {
            map_15[4]=4;map_15[5]=5;map_15[6]=6;map_15[7]=7;//блокируем весь ряд, он сложен
            return true; //возвращаемся нам повезло!!!!
        }
             Trasser_Init();//инициализация массивов
    L2:			Set_ElementPosition(5,4);
                    if(mas[4]==5)
                        map_15[4]=4; //блокируем ячейку 4 (с цифрой 5)
                    Trasser_Init();
                    Set_ElementPosition(6,5);
                    if(mas[5]==6)
                        map_15[5]=5;//блокируем ячейку 5 (с цифрой 6)
                    Trasser_Init();
                    if(mas[4]==5 && mas[5]==6)//Если цифра 5 и 6 на месте то далее
                    {
    L3:	 			Set_ElementPosition(7,7);
                        if(mas[7]==7)
                           map_15[7]=7;//блокируем ячейку 7 (с цифрой 7)
                        Trasser_Init();
                        if(mas[6]==8)//Если цифра 8 случайно была установлена на позицию 6 тогда сдвигаем ее в поз 8, если этого не сделать, то она заблокируется в ряду и ее невозможно будет вынуть
                        {
                            map_15[6]=-1;
                            map_15[7]=-1;
                            Trasser_Init();
                            Set_ElementPosition(8,14);
                            goto L3;//переход на позиционирование цифры 7 в ячейку 7
                        }

                        Set_ElementPosition(8,11);//ставим 8 в ячейку 11
                        if(mas[11]==8)
                         map_15[11]=11;//блокируем ячейку 11 (с цифрой 8)
                        Trasser_Init();
                            ZeroPositions(6);//ставим пустую ячейку на ячейку 6 //потом будем менять местами соседние ячейки
                            map_15[7]=-1; //снимаем блокировку с ячейки 7 (с цифрой 7)
                            map_15[11]=-1; //снимаем блокировку с ячейки 11 (с цифрой 8)
                            Trasser_Init();
                            SwapElements(7);//ставим  7 в ячейку 6
                            SwapElements(11);//ставим  8 в ячейку 7
                            if((mas[6]==7)&&(mas[7]==8))//если 7 и 8 в своих ячейках
                                {
                                map_15[6]=6; //блокируем ячейку 6 (с цифрой 7)
                                map_15[7]=7; //блокируем ячейку 7 (с цифрой 8)
                                }
                            Trasser_Init();
                    }
                    if(mas[4]==5&& mas[5]==6&& mas[6]==7&& mas[7]==8)// если все элементы на месте
                        result =true;
                    else
                    {

                        map_15[4]=-1;map_15[5]=-1;map_15[6]=-1;map_15[7]=-1;//снимаем блокировку с элементов строки
                        Trasser_Init();
                        goto L2;//переход на начало сборки
                    }

                    coun_er=coun_er+1;//увеличиваем счетчик ошибок
                    if(coun_er>=10)
                    {
                        if(coun_er>=100)//если серьезная проблема то выход
                        {

                            result =false;
                        }
                        goto L0;//пытаемся пройти снова
                    }


    return result;

}

//////////////////////////////////////////////////////////////

bool artificalintelligence::MakeEndLine(void)//Функция сборки элементов
{
    bool result=false;

            //int count_err1=0;//счетчик зацикливания
            int count_err2=0;//счетчик зацикливания
            //сборка остальных позиций *******************************************************
    L4:		 if(mas[8]==9&&mas[9]==10&&mas[10]==11&&mas[11]==12&&mas[12]==13&&mas[13]==14&&mas[14]==15)// Если в раскладке числа 8-15 в ячейках 9-15 т.е не на своих местах
                return true; //если все цифры на местах  возвращаемся
             if(mas[8]==9&&mas[9]==10&&mas[10]==11&&mas[11]==12&&mas[12]==13&&mas[13]==15&&mas[14]==14)// Если в раскладке числа 8-15 в ячейках 9-15 т.е не на своих местах
                return false; //нерешаемая комбинация
             Trasser_Init();

            if(!(mas[8]==9&&mas[12]==13))// Если в раскладке числа 9 и 13 в ячейках 8 и 12 т.е не на своих местах
            {
                       if(!(mas[15]==9&&(mas[10]==13||mas[11]==13)))//проверка на блокированную расстановку
                       {
                           Set_ElementPosition(9,15);//ставим 9 в ячейку 15 (правый нижний угол)
                           map_15[15]=15; // блокируем  ячейку 15 (с цифрой 9)
                           Trasser_Init();
                           if(mas[15]==9&&(mas[10]==13||mas[11]==13))//проверка на блокированную расстановку после позиционирования 9 в ячейку 15
                                goto L4;
                           Set_ElementPosition(13,8);//ставим 13 в ячейку 8 (место 9)
                           map_15[8]=8; // блокируем  ячейку 8 (с цифрой 13)
                           Trasser_Init();
                           Set_ElementPosition(9,9);//ставим 9 в ячейку 9 (место 10)
                           map_15[15]=-1; // разблокируем  ячейку 15
                           map_15[8]=-1; // разблокируем  ячейку 8 (с цифрой 13)
                           Trasser_Init();
                           ZeroPositions(12);
                           SwapElements(8);
                           SwapElements(9);
                           map_15[8]=8; //блокируем ячейку 8 (с цифрой 9)
                           map_15[12]=12; //блокируем ячейку 12 (с цифрой 13)
                           Trasser_Init();
                       }

                       else
                       {
                        map_15[15]=-1; //разблокируем ячейку 15 (с цифрой 9)
                        Trasser_Init();
                        Set_ElementPosition(13,8);//ставим 13 в ячейку 8 (место 9)
                        map_15[8]=8; //блокируем ячейку 8 (с цифрой 13)
                        Set_ElementPosition(9,9);//ставим 9 в ячейку 9 (место 10)
                        map_15[9]=9; // блокируем  ячейку 15 (с цифрой 9)
                        ZeroPositions(12);
                        map_15[8]=-1;map_15[9]=-1;
                        Trasser_Init();
                           SwapElements(8);
                           SwapElements(9);
                        map_15[8]=8; //блокируем ячейку 8 (с цифрой 9)
                        map_15[12]=12; //блокируем ячейку 12 (с цифрой 13)
                        Trasser_Init();
                       }
            }// Конец Если в раскладке числа 9 и 13 в ячейках 8 и 12 т.е не на своих местах
             if(!(mas[8]==9&&mas[12]==13)) //если ячейки не попали на свои места то делаем все снова
                  goto L4;
                    //обрабатываем ячейки 9,10,11,13,14,15

    L5:					Set_ElementPosition(10,13);//ставим 10 в ячейку 13 (место числа 14) Загоняем "10" сначала на место "14"
                        Set_ElementPosition(10,15);//ставим 10 в ячейку 15 затем ее в правый нижний угол, чтобы выстроить правильную последовательность
                        Set_ElementPosition(11,15);//ставим 11 в ячейку 15 (там где стоит число 10)
                        Set_ElementPosition(10,15);//ставим 10 в ячейку 15 (в правый нижний угол)
                        Set_ElementPosition(11,14);//ставим 11 в ячейку 14 (место числа 15)
                        Set_ElementPosition(10,11);//поднимаем 10 в ячейку 11

                        Set_ElementPosition(11,15);//под 10 ставим 11 в ячейку 15

                        Set_ElementPosition(12,14);//12 ставим в ячейку 14

                        SwapElements(11);
                        SwapElements(15);
                        SwapElements(14);
                        SwapElements(13);
                        SwapElements(9);
                        SwapElements(10);
                        SwapElements(11);
                        SwapElements(15);
                        count_err2=count_err2+1;
                        if (count_err2>4)
                        {
                            return false; //значит это нерешаемая ситуация
                        }
                    if(!(mas[8]==9&&mas[9]==10&&mas[10]==11&&mas[11]==12&&mas[12]==13))
                        goto L5;


                          if(mas[8]==9&&mas[9]==10&&mas[10]==11&&mas[11]==12&&mas[12]==13&&mas[13]==14&&mas[14]==15)// Если в раскладке числа 8-15 в ячейках 9-15 т.е не на своих местах
                        result=true; //если все OK возвращаем истина
                          else
                        result=false; //нерешаемая комбинация

    return result;

}

///////////////////////////////////////////////////////

void artificalintelligence::Set_ElementPosition(int number, int ni) //Поставить число в нужную позицию
{

    int poz_munber;
    int n_column = ni%4;//вычисляем номер колонки для позиции
    int n_line = ni/4;//вычисляем номер строки для позиции
    int  el_column;//номер колонки для элемента
    int  el_line;//номер строки для элемента
    int count_err=0; //счетчик зацикливания для ошибок
    poz_munber =  FindElements(number);

    if (ni==poz_munber)//если элемент на месте то возврат
        return;

    while(ni!=poz_munber)//выполняем пока не достигли нужной позиции
    {
      el_column = poz_munber%4;//вычисляем номер колонки для элемента
      el_line   = poz_munber/4;//вычисляем номер строки для элемента

        if(el_column<n_column)//если позиция элемента слева от нужной колонки
        {
                close_list[poz_munber]=poz_munber;//блокируем эту точку перед позиционированием пробела
                ZeroPositions(int(poz_munber+1));//устанавливаем пустую клетку справа
                SwapElements(poz_munber); //меняем местами с пустой клеткой
                close_list[poz_munber]=-1;//снимаем блокировку точки после позиционирования пробела
        }

        if(el_column>n_column)//если позиция элемента справа от нужной колонки
        {
            close_list[poz_munber]=poz_munber;//блокируем эту точку перед позиционированием пробела
            ZeroPositions(int(poz_munber-1));//устанавливаем пустую клетку слева
            SwapElements(poz_munber); //меняем местами с пустой клеткой Sleep(Delay_time);//задержка
            close_list[poz_munber]=-1;//снимаем блокировку точки после позиционирования пробела
        }

        if((el_column==n_column)&&(el_line>n_line))//если элемент находится в колонке но его позиция ниже нужной строки
        {
            close_list[poz_munber]=poz_munber;//блокируем эту точку перед позиционированием пробела
            ZeroPositions(int(poz_munber-4));//устанавливаем пустую клетку сверху
            SwapElements(poz_munber); //меняем местами с пустой клеткой
            close_list[poz_munber]=-1;//снимаем блокировку точки после позиционирования пробела
        }
        if((el_column==n_column)&&(el_line<n_line))//если элемент находится в колонке но его позиция выше нужной строки
        {
            close_list[poz_munber]=poz_munber;//блокируем эту точку перед позиционированием пробела
            ZeroPositions(int(poz_munber+4));//устанавливаем пустую клетку снизу
            SwapElements(poz_munber); //меняем местами с пустой клеткой
            close_list[poz_munber]=-1;//снимаем блокировку точки после позиционирования пробела
        }

        if(count_err==100000)//блок контроля ошибок
        {
            //std::cout << "error!" << std::endl;
            break;
        }
        Trasser_Init();//инициализация массивов трассировки
        poz_munber =  FindElements(number);
        count_err=count_err+1;
    }

        return;

}

/////////////////////////////////////////////////////////////////////////////////////

void artificalintelligence::ZeroPositions(int n) //функция сдвинуть пустую ячейку в любую нужную позицию
{

    int p_zero=FindElements(0);//находим адрес "0" в таблице
    int _i;
    /*static int patch[16];*/

    if(p_zero==n)//если ноль уже в нужной позиции то возврат
        return;

      Trasser_patch(p_zero,n);//создаем маршрут от положения 0 к указанной точке

    for (_i=0;_i<16;_i++)//перебор точек маршрута
    {
        if(trassa[_i]!=-1)//если есть точка (число не равное -1)

        {
           SwapElements(trassa[_i]);//меняем 0 с элементом маршрута
           //Sleep(Delay_time);//задержка
        }
    }
Trasser_Init();
return;
}


/////////////////////////////////////////////////////////////////////////////

void  artificalintelligence::Trasser_patch(int start, int finish)//создаем машрут из точки А в точку В (алгоритм А*)***********************************************
{
    int rod = start; //начальный родитель - стартовая точка
        int old_rod = start;//предыдущий родитель - стартовая точка
        int count_rod =0;
        int _i;
        int direct =0; //количесво разрешенных направлений из данной точки
        int count_point=0;//счетчик точек маршрута
        int count_err=0;//счетчик зацикливания для ошибок;
        int n_step; //кол-во перемещений в данную точку из стартовой

        open_list[start].Poz =start; //позиция элемента
        open_list[start].G =0;//G = стоимость передвижения из стартовой точки A к данной клетке, следуя найденному пути к этой клетке.
                              //(будем считать что стоимость передвижения на 1 позицию =10)
        open_list[start].H =Steps(start,finish)*10;//H = примерная стоимость передвижения от данной клетки до целевой, то есть точки B. Она обычно является эвристической функцией.
                                                   //Стоимость H посчитана с помощью вычисления Манхеттенского расстояния к точке В,
                                                   //двигаясь только по горизонтали и вертикали, игнорируя все препятствия на пути.
        open_list[start].F = open_list[start].G + open_list[start].H; //Стоимость F для каждой клетки вычисляется простым суммированием G и H.
        //open_list[start].Dst = abs(finish-start); //разность между начальной точкой и конечной

        for(_i=0;_i<16;_i++)//добавление в закрытый список элементов из списка блокировки
        {
            if(n_block[_i]==_i)//если позиция списка блокировки содержит номер позиции (-1 значит не блокирован)
            close_list[_i]=_i;//добавляем его в закрытый список
        }

        open_list[finish].Poz =finish;//добавим в открытый список конечную точку
        open_list[finish].H =-1;//инициализация финишной точки, чтобы мы могли войти в цикл

        while(open_list[finish].H!=0) //строим маршрут пока не достигли конечной точки т.е при H=0 мы находимся в кон. точке
        {
            direct =Trasser_Area(rod);//формируем масив mass_a окружения родительской точки и определяем число направлений из родительской точки
            close_list[rod] =rod; //заносим стартовую точку в закрытый список

            for(_i=0;_i<4;_i++)//заполняем open_list исходя из массива окружения родителя
            {
                n_step =10;//инициализация стомости перехода на 1 шаг
                int _ar = mass_a[_i];//сохраняем элемент окружения в open_list  (в этом массиве [0] -точка справа [1]-точка слева [2]-точка сверху [3]-точка снизу)
                    if( _ar!=-1)//если элемент = -1 то соседней точки с какой либо стороны нет либо она заблокирована в close_list
                    {
                        open_list[_ar].Poz =_ar; //позиция элемента

                        for(int _c=0;_c<16;_c++) //сканируем уже созданную часть маршрута и считаем сколько ячеек мы уже прошли
                        {
                            if(trassa[_c]!=-1)
                                n_step=n_step+10;//определим стоимость передвижения из одной ячейки =10 и будем ее накапливать
                        }
                        open_list[_ar].G =n_step; //заносим стоимость перемещения из стартовой в эту ячейку
                        open_list[_ar].H =((Steps(_ar,finish))*10);//заносим стоимость перемещения из данной ячейки в конечную
                        open_list[_ar].F = open_list[_ar].G + open_list[_ar].H;//вычисляем F=G+H;
                        open_list[_ar].Direct = direct;//записываем кол-во разрешенных направлений из родительской точки;
                    }
            }
            old_rod = rod;
            rod = Trass_Parent(rod);//получаем родителя

            if(count_point<16&&old_rod!=rod)//если счетчик циклов не превышает размер массива маршрута и старый и новый родители не совпадают
            {
                trassa[count_point]=rod;//записываем точку маршрута в массив
                count_point=count_point+1;//увеличиваем счетчик точек маршрута
                Min_F=100;
            }
            if(old_rod==rod)//если  старый и новый родители совпадают будем их подсчитывать
               count_rod=count_rod+1;
            if(count_rod==10)
            {
                break;
            }

            if(count_err==100)//блок контроля ошибок
            {
                break;
            }
            if(count_point>=16)//блок контроля ошибок
            {
                break;
            }
        }//End while

    return;
}
int artificalintelligence::FindElements(int D)
{
    int poz;
    for(int _i=0;_i<16;_i++)
        {
            if(mas[_i]==D)
                poz = _i;
        }

    return poz;
}
/////////////////////////////////////////////////////////////////

void artificalintelligence::SwapElements(int num) //функция обмен местами элементов если пустая ячейка рядом
{
    int zero;
    for(int _i=0;_i<16;_i++)
        {
            if(mas[_i]==0)
                zero = _i;
        }

    if(num==zero+1||num==zero-1||num==zero-4||num==zero+4)//если рядом с элементом по адресу num находится пробел
        {
            mas[zero]=mas[num];//записываем значение элемента в ячейку где был 0
            mas[num]=0;			//записываем 0 в ячейку где был элемент
        }

    return;
}

int artificalintelligence::Steps(int a1, int a2)
{
    int step=0, tmp;
        int count_err=0; //счетчик зацикливания для ошибок
        if (a2<a1)
        {
            tmp=a2;
            a2=a1;
            a1 =tmp;
        }
            while(a1!=a2)
            {
                if(a2>a1&&a1/4!=a2/4) //если а2 больше а1 и они в разных строках
                {
                    a1=a1+4;//переходим на другую строку
                    step=step+1;//делаем шаг
                }
                if(a2>a1&&a1/4==a2/4) //если а2 больше а1 и они в одной строке
                {
                    a1=a1+1;//переходим на другую ячейку
                    step=step+1;//делаем шаг
                }
                if(a2<a1)
                {
                    a1=a1-1;
                    step=step+1;
                }

                if(count_err==1000)//блок контроля ошибок
                {

                break;
                }
                count_err=count_err+1;
            }

    return step;
}

int artificalintelligence::Trass_Parent(int parent)
{
    int _i,el;

        //int Min_dist = 16;//номер элемента с минимальным F (инициализация вне области)


        for(_i=0;_i<4;_i++)
        {
            el = mass_a[_i];
            if(el!=-1)
            {

                if (Min_F >=open_list[el].F)
                {
                /*	 if(Min_H >=open_list[el].H)
                        Min_H = open_list[el].H;*/

                     if(open_list[el].Direct!=0)//исключаем напрвления с тупиками
                    {
                       Min_F =  open_list[el].F;
                       parent =  open_list[el].Poz;

                    }
                }
            }
        }

        return  parent;
}


int artificalintelligence::Trasser_Area(int aa)
{
    int d=0;//кол-во направлений из этой точки
        int _r;
        if((aa-1)/4==(aa/4))//есть ли рядом слева элемент на той же строке
        {
            if(!Check_Block_Position(aa-1))//если элемент слева не блокирован
               mass_a[0]=aa-1; //записываем он не блокирован
            else
               mass_a[0]=-1;  //не записываем, он блокирован
        }
        else
        mass_a[0] =-1;//елемента слева нет он за левой границей

        if((aa+1)<=15&&(aa+1)/4==aa/4)//есть ли рядом справа элемент на той же строке
        {
            if(!Check_Block_Position(aa+1))//если элемент справа не блокирован
              mass_a[1]=aa+1; //записываем он не блокирован
            else
              mass_a[1]=-1;	 //не записываем, он блокирован
        }
        else
        mass_a[1] =-1;//елемента справа нет он за правой границей

        if((aa-4)>=0)//есть ли над этим элементом элемент выше
        {
            if(!Check_Block_Position(aa-4))//если элемент сверху не блокирован
                mass_a[2]=aa-4;//записываем он не блокирован
            else
                mass_a[2]=-1;	 //не записываем, он блокирован
        }
        else
        mass_a[2] =-1;//елемента сверху нет он за верхней границей

        if((aa+4)<=15)//есть ли над этим элементом элемент ниже
        {
            if(!Check_Block_Position(aa+4))//если элемент снизу не блокирован
                mass_a[3]=aa+4;//записываем он не блокирован
            else
                mass_a[3]=-1;	 //не записываем, он блокирован
        }
        else
        mass_a[3] =-1;//елемента снизу нет он за нижней границей

        for(_r=0;_r<4;_r++)//подсчет числа направлений
        {
         if(mass_a[_r]!=-1)
             d=d+1;
        }
        return d;
}

bool artificalintelligence::Check_Block_Position(int p)
{
    bool result=false;//не блокирован
        for(int _i=0;_i<16;_i++)
        {
            if(p==_i&&p==close_list[_i])//проверяем значение в закрытом списке (если заблокирован то элемен массива содержит этот индекс=р)
            result=true;//блокирован
        }
    return result;
}

void artificalintelligence::Map_15ToBoard()
{

    for(size_t i = 0, k = 0; i < 3; ++i)
        for(size_t j = 0; j < 4; ++j)
            boardAI[i][j] = mas[k++];
}



void artificalintelligence::showBoardAI()
{
   system("clear") ;
   std::cout << "Демонстрация работы ИИ для пятнашек.\n";

   for (int i = 0; i < SZ_X; i++)
   {
       std::cout << "_____________" << std::endl;
       std::cout << "|";
       Map_15ToBoard();
       for (int j = 0; j < SZ_Y; j++)
       {
           std::cout << std::left
               << std::setw(2)
               << boardAI[i][j]
               << "|";
       }
       std::cout << std::endl;
   }
   std::cout << "_____________" << std::endl;
}
